io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value:  key may 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value:  signatures.  Because the specified 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: ' signature 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: algorithm, but the provided 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: key reflects a specific and expected algorithm, and the JWT does not reflect 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: not be used to verify 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: signature verification key, but this cannot be assumed for security reasons.
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: this algorithm, it is likely that the JWT was not expected and therefore should not be 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: trusted.  Another possibility is that the parser was provided the incorrect 
io/jsonwebtoken/impl/DefaultJwtParser	validateExpectedClaims	(Lio/jsonwebtoken/Header;Lio/jsonwebtoken/Claims;)V	CONSTANT	 type: class java.lang.String; value: ' was expected to be a Date, but its value 
io/jsonwebtoken/impl/DefaultJwtParser	validateExpectedClaims	(Lio/jsonwebtoken/Header;Lio/jsonwebtoken/Claims;)V	CONSTANT	 type: class java.lang.String; value: cannot be converted to a Date using current heuristics.  Value: 
io/jsonwebtoken/impl/crypto/EllipticCurveProvider	<init>	(Lio/jsonwebtoken/SignatureAlgorithm;Ljava/security/Key;)V	CONSTANT	 type: class java.lang.String; value:  per [RFC 7518, Section 3.4 (validation)]
io/jsonwebtoken/impl/crypto/EllipticCurveProvider	<init>	(Lio/jsonwebtoken/SignatureAlgorithm;Ljava/security/Key;)V	CONSTANT	 type: class java.lang.String; value: (https://datatracker.ietf.org/doc/html/rfc7518#section-3.4).
io/jsonwebtoken/impl/crypto/EllipticCurveSignatureValidator	isValid	([B[B)Z	CONSTANT	 type: class java.lang.String; value:  per 
io/jsonwebtoken/impl/crypto/EllipticCurveSignatureValidator	isValid	([B[B)Z	CONSTANT	 type: class java.lang.String; value: [RFC 7518, Section 3.4 (validation)](https://datatracker.ietf.org/doc/html/rfc7518#section-3.4).
io/jsonwebtoken/impl/crypto/MacProvider	generateKey	(Lio/jsonwebtoken/SignatureAlgorithm;Ljava/security/SecureRandom;)Ljavax/crypto/SecretKey;	CONSTANT	 type: class java.lang.String; value:  algorithm is not available.  
io/jsonwebtoken/impl/crypto/MacProvider	generateKey	(Lio/jsonwebtoken/SignatureAlgorithm;Ljava/security/SecureRandom;)Ljavax/crypto/SecretKey;	CONSTANT	 type: class java.lang.String; value: This should never happen on JDK 7 or later - please report this to the JJWT developers.
