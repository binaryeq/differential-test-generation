io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value:  key may not be used to verify 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value:  signatures.  Because the specified key reflects a specific and expected algorithm, and the JWT does not reflect this algorithm, it is likely that the JWT was not expected and therefore should not be trusted.  Another possibility is that the parser was provided the incorrect signature verification key, but this cannot be assumed for security reasons.
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/lang/String;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: ' signature algorithm, but the provided 
io/jsonwebtoken/impl/DefaultJwtParser	validateExpectedClaims	(Lio/jsonwebtoken/Header;Lio/jsonwebtoken/Claims;)V	CONSTANT	 type: class java.lang.String; value: ' was expected to be a Date, but its value cannot be converted to a Date using current heuristics.  Value: 
io/jsonwebtoken/impl/crypto/EllipticCurveProvider	<init>	(Lio/jsonwebtoken/SignatureAlgorithm;Ljava/security/Key;)V	CONSTANT	 type: class java.lang.String; value:  per [RFC 7518, Section 3.4 (validation)](https://datatracker.ietf.org/doc/html/rfc7518#section-3.4).
io/jsonwebtoken/impl/crypto/EllipticCurveSignatureValidator	isValid	([B[B)Z	CONSTANT	 type: class java.lang.String; value:  per [RFC 7518, Section 3.4 (validation)](https://datatracker.ietf.org/doc/html/rfc7518#section-3.4).
io/jsonwebtoken/impl/crypto/MacProvider	generateKey	(Lio/jsonwebtoken/SignatureAlgorithm;Ljava/security/SecureRandom;)Ljavax/crypto/SecretKey;	CONSTANT	 type: class java.lang.String; value:  algorithm is not available.  This should never happen on JDK 7 or later - please report this to the JJWT developers.
