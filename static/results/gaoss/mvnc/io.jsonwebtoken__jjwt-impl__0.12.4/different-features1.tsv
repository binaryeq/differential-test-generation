io/jsonwebtoken/impl/DefaultJwtParser	<clinit>	()V	CONSTANT	 type: class java.lang.String; value:  header parameter per https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.11 ("the [crit] Header Parameter MUST be integrity protected; therefore, it MUST occur only within [a] JWS Protected Header)". Header: %s
io/jsonwebtoken/impl/DefaultJwtParser	<clinit>	()V	CONSTANT	 type: class java.lang.String; value:  header value of false) that also rely on a SigningKeyResolver are disallowed by default to protect against [Denial of Service attacks](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-pellegrino.pdf).  If you wish to enable Unsecure JWS or Unencoded JWS payload decompression, call the JwtParserBuilder.unsecuredDecompression() method, but please read the security considerations covered in that method's JavaDoc before doing so.
io/jsonwebtoken/impl/DefaultJwtParser	<clinit>	()V	CONSTANT	 type: class java.lang.String; value:  header value of false) that rely on a SigningKeyResolver are disallowed by default to protect against [Denial of Service attacks](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-pellegrino.pdf).  If you wish to enable Unencoded JWS payload decompression, configure the JwtParserBuilder.keyLocator(Locator) and do not configure a SigningKeyResolver.
io/jsonwebtoken/impl/DefaultJwtParser	<clinit>	()V	CONSTANT	 type: class java.lang.String; value:  set references header name '%s', but the header does not contain an associated '%s' header parameter as required by https://www.rfc-editor.org/rfc/rfc7515.html#section-4.1.11. Header: %s
io/jsonwebtoken/impl/DefaultJwtParser	<clinit>	()V	CONSTANT	 type: class java.lang.String; value:  set references unsupported header name '%s'. Application developers expecting to support a JWT extension using header '%s' in their application code must indicate it is supported by using the JwtParserBuilder.critical method. Header: %s
io/jsonwebtoken/impl/DefaultJwtParser	<clinit>	()V	CONSTANT	 type: class java.lang.String; value: ' per https://www.rfc-editor.org/rfc/rfc7518.html#section-4.1
io/jsonwebtoken/impl/DefaultJwtParser	<clinit>	()V	CONSTANT	 type: class java.lang.String; value: ' yet the compact JWS string contains a signature. This is not permitted per https://tools.ietf.org/html/rfc7518#section-3.6.
io/jsonwebtoken/impl/DefaultJwtParser	<clinit>	()V	CONSTANT	 type: class java.lang.String; value: ') are disallowed by default as mandated by https://www.rfc-editor.org/rfc/rfc7518.html#section-3.6. If you wish to allow them to be parsed, call the JwtParserBuilder.unsecured() method, but please read the security considerations covered in that method's JavaDoc before doing so. Header: 
io/jsonwebtoken/impl/DefaultJwtParser	parse	(Ljava/io/Reader;Lio/jsonwebtoken/impl/Payload;)Lio/jsonwebtoken/Jwt;	CONSTANT	 type: class java.lang.String; value: ' JWE key algorithm did not return a decryption key. Unable to perform '
io/jsonwebtoken/impl/DefaultJwtParser	validateExpectedClaims	(Lio/jsonwebtoken/Header;Lio/jsonwebtoken/Claims;)V	CONSTANT	 type: class java.lang.String; value: ' was expected to be a Date, but its value cannot be converted to a Date using current heuristics.  Value: 
io/jsonwebtoken/impl/DefaultJwtParser	verifySignature	(Lio/jsonwebtoken/impl/TokenizedJwt;Lio/jsonwebtoken/JwsHeader;Ljava/lang/String;Lio/jsonwebtoken/SigningKeyResolver;Lio/jsonwebtoken/Claims;Lio/jsonwebtoken/impl/Payload;)V	CONSTANT	 type: class java.lang.String; value:  key may not be used to verify 
io/jsonwebtoken/impl/DefaultJwtParser	verifySignature	(Lio/jsonwebtoken/impl/TokenizedJwt;Lio/jsonwebtoken/JwsHeader;Ljava/lang/String;Lio/jsonwebtoken/SigningKeyResolver;Lio/jsonwebtoken/Claims;Lio/jsonwebtoken/impl/Payload;)V	CONSTANT	 type: class java.lang.String; value:  signatures.  Because the specified key reflects a specific and expected algorithm, and the JWT does not reflect this algorithm, it is likely that the JWT was not expected and therefore should not be trusted.  Another possibility is that the parser was provided the incorrect signature verification key, but this cannot be assumed for security reasons.
io/jsonwebtoken/impl/DefaultJwtParser	verifySignature	(Lio/jsonwebtoken/impl/TokenizedJwt;Lio/jsonwebtoken/JwsHeader;Ljava/lang/String;Lio/jsonwebtoken/SigningKeyResolver;Lio/jsonwebtoken/Claims;Lio/jsonwebtoken/impl/Payload;)V	CONSTANT	 type: class java.lang.String; value: ' signature algorithm, but the provided 
io/jsonwebtoken/impl/lang/DefaultParameter	cast	(Ljava/lang/Object;)Ljava/lang/Object;	CONSTANT	 type: class java.lang.String; value: >: At least one element is not an instance of 
io/jsonwebtoken/impl/security/AbstractSecureDigestAlgorithm	digest	(Lio/jsonwebtoken/security/SecureRequest;)[B	CONSTANT	 type: class java.lang.String; value: ' using key {
io/jsonwebtoken/impl/security/AbstractSecureDigestAlgorithm	verify	(Lio/jsonwebtoken/security/VerifySecureDigestRequest;)Z	CONSTANT	 type: class java.lang.String; value: ' using key {
io/jsonwebtoken/impl/security/AesAlgorithm	assertKeyBitLength	(I)V	CONSTANT	 type: class java.lang.String; value: . AES only supports 128, 192, or 256 bit keys.
io/jsonwebtoken/impl/security/DefaultMacAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value:  MUST have a size >= 
io/jsonwebtoken/impl/security/DefaultMacAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value:  bits (the key size must be greater than or equal to the hash output size). Consider using the Jwts.SIG.
io/jsonwebtoken/impl/security/DefaultMacAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value:  bits which is not secure enough for the 
io/jsonwebtoken/impl/security/DefaultMacAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value: .  See https://tools.ietf.org/html/rfc7518#section-3.2 for more information.
io/jsonwebtoken/impl/security/DefaultMacAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value: .key() builder to create a key guaranteed to be secure enough for 
io/jsonwebtoken/impl/security/DefaultRsaKeyAlgorithm	validate	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value:  algorithm. The JWT JWA Specification (RFC 7518, Section 
io/jsonwebtoken/impl/security/DefaultRsaKeyAlgorithm	validate	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value:  bits. See https://www.rfc-editor.org/rfc/rfc7518.html#section-
io/jsonwebtoken/impl/security/DefaultRsaKeyAlgorithm	validate	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value: ) states that RSA keys MUST have a size >= 
io/jsonwebtoken/impl/security/EcSignatureAlgorithm$2	apply	(Ljava/security/Signature;)Ljava/lang/Boolean;	CONSTANT	 type: class java.lang.String; value:  per [RFC 7518, Section 3.4 (validation)](https://www.rfc-editor.org/rfc/rfc7518.html#section-3.4).
io/jsonwebtoken/impl/security/EcdhKeyAlgorithm	assertCurve	(Ljava/security/Key;)Lio/jsonwebtoken/impl/security/AbstractCurve;	CONSTANT	 type: class java.lang.String; value:  keys may not be used with ECDH-ES key agreement algorithms per https://www.rfc-editor.org/rfc/rfc8037#section-3.1.
io/jsonwebtoken/impl/security/EcdhKeyAlgorithm	getDecryptionKey	(Lio/jsonwebtoken/security/DecryptionKeyRequest;)Ljavax/crypto/SecretKey;	CONSTANT	 type: class java.lang.String; value:  value does not represent a point on the expected curve. Value: 
io/jsonwebtoken/impl/security/EcdhKeyAlgorithm	getDecryptionKey	(Lio/jsonwebtoken/security/DecryptionKeyRequest;)Ljavax/crypto/SecretKey;	CONSTANT	 type: class java.lang.String; value:  value is not an Elliptic Curve Public JWK. Value: 
io/jsonwebtoken/impl/security/EdSignatureAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value:  digital signatures per https://www.rfc-editor.org/rfc/rfc8037.html#section-3.2
io/jsonwebtoken/impl/security/Pbes2HsAkwAlgorithm	getDecryptionKey	(Lio/jsonwebtoken/security/DecryptionKeyRequest;)Ljavax/crypto/SecretKey;	CONSTANT	 type: class java.lang.String; value:  maximum allowed value 
io/jsonwebtoken/impl/security/Pbes2HsAkwAlgorithm	getDecryptionKey	(Lio/jsonwebtoken/security/DecryptionKeyRequest;)Ljavax/crypto/SecretKey;	CONSTANT	 type: class java.lang.String; value: . The larger value is rejected to help mitigate potential Denial of Service attacks.
io/jsonwebtoken/impl/security/RsaPrivateJwkFactory	<clinit>	()V	CONSTANT	 type: class java.lang.String; value:  interfaces.  If the specified RSAPrivateKey cannot be one of these two, you must explicitly provide an RSAPublicKey in addition to the RSAPrivateKey, as the [JWA RFC, Section 6.3.2](https://www.rfc-editor.org/rfc/rfc7518.html#section-6.3.2) requires public values to be present in private RSA JWKs.
io/jsonwebtoken/impl/security/RsaSignatureAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value:  algorithm.  The JWT JWA Specification (RFC 7518, Section 
io/jsonwebtoken/impl/security/RsaSignatureAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value:  bits which is not secure enough for the 
io/jsonwebtoken/impl/security/RsaSignatureAlgorithm	validateKey	(Ljava/security/Key;Z)V	CONSTANT	 type: class java.lang.String; value: .  See https://tools.ietf.org/html/rfc7518#section-
io/jsonwebtoken/impl/security/SecretJwkFactory	assertKeyBitLength	([BLio/jsonwebtoken/security/MacAlgorithm;)V	CONSTANT	 type: class java.lang.String; value:  required by [JWA RFC 7518, Section 3.2](https://www.rfc-editor.org/rfc/rfc7518.html#section-3.2), 2nd paragraph: 'A key of the same size as the hash output or larger MUST be used with this algorithm.'
io/jsonwebtoken/impl/security/SecretJwkFactory	assertSymmetric	(Lio/jsonwebtoken/Identifiable;)V	CONSTANT	 type: class java.lang.String; value: '. Secret JWKs may only be used with symmetric (secret) key algorithms.
