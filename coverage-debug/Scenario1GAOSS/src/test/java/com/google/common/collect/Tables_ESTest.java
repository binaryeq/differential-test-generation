/*
 * This file was automatically generated by EvoSuite
 * Wed Oct 23 15:49:55 GMT 2024
 */

package com.google.common.collect;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import com.google.common.collect.ContiguousSet;
import com.google.common.collect.DiscreteDomain;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Range;
import com.google.common.collect.RegularContiguousSet;
import com.google.common.collect.Table;
import com.google.common.collect.Tables;
import com.google.common.collect.TreeBasedTable;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Tables_ESTest extends Tables_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test0()  throws Throwable  {
      Integer integer0 = new Integer(1688);
      Range<Integer> range0 = Range.lessThan(integer0);
      DiscreteDomain<Integer> discreteDomain0 = DiscreteDomain.integers();
      RegularContiguousSet<Integer> regularContiguousSet0 = new RegularContiguousSet<Integer>(range0, discreteDomain0);
      TreeBasedTable<Integer, Integer, Locale.Category> treeBasedTable0 = TreeBasedTable.create();
      Tables.UnmodifiableRowSortedMap<Integer, Integer, Locale.Category> tables_UnmodifiableRowSortedMap0 = new Tables.UnmodifiableRowSortedMap<Integer, Integer, Locale.Category>(treeBasedTable0);
      HashMap<Integer, Locale.Category> hashMap0 = new HashMap<Integer, Locale.Category>();
      Table.Cell<ContiguousSet<Integer>, Tables.UnmodifiableRowSortedMap<Integer, Integer, Locale.Category>, HashMap<Integer, Locale.Category>> table_Cell0 = Tables.immutableCell((ContiguousSet<Integer>) regularContiguousSet0, tables_UnmodifiableRowSortedMap0, hashMap0);
      assertNotNull(table_Cell0);
  }

  @Test(timeout = 4000)
  public void test1()  throws Throwable  {
      Integer integer0 = new Integer(1216);
      HashMap<Integer, Integer> hashMap0 = new HashMap<Integer, Integer>();
      Tables.ImmutableCell<Integer, HashMap<Integer, Integer>, Comparable<Integer>> tables_ImmutableCell0 = new Tables.ImmutableCell<Integer, HashMap<Integer, Integer>, Comparable<Integer>>(integer0, hashMap0, integer0);
      Comparable<Integer> comparable0 = tables_ImmutableCell0.getValue();
      assertEquals(1216, comparable0);
  }

  @Test(timeout = 4000)
  public void test2()  throws Throwable  {
      Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.IGNORE_EXTENDED_RANGES;
      HashMap<Locale.FilteringMode, Locale.FilteringMode> hashMap0 = new HashMap<Locale.FilteringMode, Locale.FilteringMode>();
      Tables.ImmutableCell<Locale.FilteringMode, HashMap<Locale.FilteringMode, Locale.FilteringMode>, HashMap<Locale.FilteringMode, Locale.FilteringMode>> tables_ImmutableCell0 = new Tables.ImmutableCell<Locale.FilteringMode, HashMap<Locale.FilteringMode, Locale.FilteringMode>, HashMap<Locale.FilteringMode, Locale.FilteringMode>>(locale_FilteringMode0, hashMap0, hashMap0);
      Locale.FilteringMode locale_FilteringMode1 = tables_ImmutableCell0.getRowKey();
      assertSame(locale_FilteringMode1, locale_FilteringMode0);
  }

  @Test(timeout = 4000)
  public void test3()  throws Throwable  {
      HashBasedTable<Object, Object, Integer> hashBasedTable0 = HashBasedTable.create(4236, 4236);
      Integer integer0 = new Integer(4236);
      boolean boolean0 = Tables.equalsImpl(hashBasedTable0, integer0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test4()  throws Throwable  {
      HashMap<Integer, Integer> hashMap0 = new HashMap<Integer, Integer>();
      Tables.ImmutableCell<HashMap<Integer, Integer>, HashMap<Integer, Integer>, HashMap<Integer, Integer>> tables_ImmutableCell0 = new Tables.ImmutableCell<HashMap<Integer, Integer>, HashMap<Integer, Integer>, HashMap<Integer, Integer>>(hashMap0, hashMap0, hashMap0);
      boolean boolean0 = tables_ImmutableCell0.equals((Object) null);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test5()  throws Throwable  {
      TreeBasedTable<Map<Integer, Integer>, Integer, Map<Integer, Integer>> treeBasedTable0 = new TreeBasedTable<Map<Integer, Integer>, Integer, Map<Integer, Integer>>((Comparator<? super Map<Integer, Integer>>) null, (Comparator<? super Integer>) null);
      Tables.UnmodifiableRowSortedMap<Map<Integer, Integer>, Object, Map<Integer, Integer>> tables_UnmodifiableRowSortedMap0 = new Tables.UnmodifiableRowSortedMap<Map<Integer, Integer>, Object, Map<Integer, Integer>>(treeBasedTable0);
      SortedSet<Map<Integer, Integer>> sortedSet0 = tables_UnmodifiableRowSortedMap0.rowKeySet();
      assertEquals(0, sortedSet0.size());
  }

  @Test(timeout = 4000)
  public void test6()  throws Throwable  {
      TreeBasedTable<Map<Integer, Integer>, Integer, Map<Integer, Integer>> treeBasedTable0 = new TreeBasedTable<Map<Integer, Integer>, Integer, Map<Integer, Integer>>((Comparator<? super Map<Integer, Integer>>) null, (Comparator<? super Integer>) null);
      Tables.UnmodifiableRowSortedMap<Map<Integer, Integer>, Object, Map<Integer, Integer>> tables_UnmodifiableRowSortedMap0 = new Tables.UnmodifiableRowSortedMap<Map<Integer, Integer>, Object, Map<Integer, Integer>>(treeBasedTable0);
      Set<Table.Cell<Map<Integer, Integer>, Object, Map<Integer, Integer>>> set0 = (Set<Table.Cell<Map<Integer, Integer>, Object, Map<Integer, Integer>>>)tables_UnmodifiableRowSortedMap0.cellSet();
      assertTrue(set0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test7()  throws Throwable  {
      Integer integer0 = new Integer(1216);
      HashMap<Integer, Integer> hashMap0 = new HashMap<Integer, Integer>();
      Tables.ImmutableCell<Integer, HashMap<Integer, Integer>, Object> tables_ImmutableCell0 = new Tables.ImmutableCell<Integer, HashMap<Integer, Integer>, Object>(integer0, hashMap0, hashMap0);
      Integer integer1 = hashMap0.remove((Object) tables_ImmutableCell0);
      assertNull(integer1);
  }

  @Test(timeout = 4000)
  public void test8()  throws Throwable  {
      Integer integer0 = new Integer(40);
      Comparable<Object> comparable0 = (Comparable<Object>) mock(Comparable.class, new ViolatedAssumptionAnswer());
      doReturn((String) null, (String) null).when(comparable0).toString();
      Tables.ImmutableCell<Integer, Comparable<Object>, Comparable<Integer>> tables_ImmutableCell0 = new Tables.ImmutableCell<Integer, Comparable<Object>, Comparable<Integer>>(integer0, comparable0, integer0);
      String string0 = tables_ImmutableCell0.toString();
      assertEquals("(40,null)=40", string0);
  }
}
