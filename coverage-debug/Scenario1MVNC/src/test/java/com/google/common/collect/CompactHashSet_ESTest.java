/*
 * This file was automatically generated by EvoSuite
 * Wed Oct 23 14:44:17 GMT 2024
 */

package com.google.common.collect;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.BoundType;
import com.google.common.collect.CompactHashSet;
import com.google.common.collect.FilteredKeyMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMapEntrySet;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.ImmutableSortedMultiset;
import com.google.common.collect.JdkBackedImmutableSet;
import com.google.common.collect.Multisets;
import com.google.common.collect.Range;
import com.google.common.collect.RegularImmutableAsList;
import com.google.common.collect.RegularImmutableSet;
import com.google.common.collect.UnmodifiableSortedMultiset;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.Spliterator;
import java.util.Stack;
import java.util.function.Consumer;
import java.util.stream.Stream;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class CompactHashSet_ESTest extends CompactHashSet_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Object object0 = new Object();
      Object[] objectArray0 = new Object[2];
      objectArray0[0] = object0;
      RegularImmutableSet<JdkBackedImmutableSet<BoundType>> regularImmutableSet0 = new RegularImmutableSet<JdkBackedImmutableSet<BoundType>>(objectArray0, 3001, objectArray0, (-2507));
      CompactHashSet<JdkBackedImmutableSet<BoundType>> compactHashSet0 = CompactHashSet.create((Collection<? extends JdkBackedImmutableSet<BoundType>>) regularImmutableSet0);
      CompactHashSet<JdkBackedImmutableSet<BoundType>> compactHashSet1 = CompactHashSet.create((Collection<? extends JdkBackedImmutableSet<BoundType>>) compactHashSet0);
      assertEquals(2, compactHashSet0.size());
      assertTrue(compactHashSet1.equals((Object)compactHashSet0));
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      CompactHashSet<Object> compactHashSet0 = CompactHashSet.createWithExpectedSize(386);
      int int0 = compactHashSet0.getSuccessor(653);
      assertEquals((-1), int0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      CompactHashSet<Integer> compactHashSet0 = CompactHashSet.create();
      Object object0 = new Object();
      Object object1 = new Object();
      Object object2 = new Object();
      Object object3 = new Object();
      Object object4 = new Object();
      Object[] objectArray0 = new Object[6];
      objectArray0[0] = object4;
      objectArray0[1] = object1;
      objectArray0[2] = object3;
      objectArray0[3] = object0;
      objectArray0[4] = object2;
      RegularImmutableSet<JdkBackedImmutableSet<BoundType>> regularImmutableSet0 = new RegularImmutableSet<JdkBackedImmutableSet<BoundType>>(objectArray0, 117, objectArray0, 0);
      CompactHashSet<JdkBackedImmutableSet<BoundType>> compactHashSet1 = CompactHashSet.create((Collection<? extends JdkBackedImmutableSet<BoundType>>) regularImmutableSet0);
      BoundType boundType0 = BoundType.OPEN;
      ImmutableList<BoundType> immutableList0 = ImmutableList.of(boundType0);
      JdkBackedImmutableSet<BoundType> jdkBackedImmutableSet0 = new JdkBackedImmutableSet<BoundType>(compactHashSet0, immutableList0);
      compactHashSet1.add(jdkBackedImmutableSet0);
      assertEquals(7, compactHashSet1.size());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      LinkedHashSet<Locale.Category>[] linkedHashSetArray0 = (LinkedHashSet<Locale.Category>[]) Array.newInstance(LinkedHashSet.class, 3);
      LinkedHashSet<Locale.Category> linkedHashSet0 = new LinkedHashSet<Locale.Category>();
      linkedHashSetArray0[0] = linkedHashSet0;
      CompactHashSet<LinkedHashSet<Locale.Category>> compactHashSet0 = CompactHashSet.create(linkedHashSetArray0);
      compactHashSet0.convertToHashFloodingResistantImplementation();
      assertTrue(compactHashSet0.contains(linkedHashSet0));
      assertEquals(2, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      Locale.FilteringMode[] locale_FilteringModeArray0 = new Locale.FilteringMode[6];
      CompactHashSet<Locale.FilteringMode> compactHashSet0 = CompactHashSet.create(locale_FilteringModeArray0);
      compactHashSet0.init(9);
      assertEquals(1, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      CompactHashSet<BoundType> compactHashSet0 = new CompactHashSet<BoundType>(0);
      compactHashSet0.incrementModCount();
      assertTrue(compactHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      CompactHashSet<UnmodifiableSortedMultiset<BoundType>> compactHashSet0 = CompactHashSet.createWithExpectedSize(847);
      BoundType[] boundTypeArray0 = new BoundType[0];
      BoundType[] boundTypeArray1 = compactHashSet0.toArray(boundTypeArray0);
      assertSame(boundTypeArray0, boundTypeArray1);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Object[] objectArray0 = new Object[9];
      CompactHashSet<Object> compactHashSet0 = CompactHashSet.create(objectArray0);
      Object[] objectArray1 = compactHashSet0.toArray();
      assertEquals(1, objectArray1.length);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.AUTOSELECT_FILTERING;
      ImmutableMultiset<Locale.FilteringMode> immutableMultiset0 = ImmutableMultiset.of(locale_FilteringMode0, locale_FilteringMode0, locale_FilteringMode0, locale_FilteringMode0);
      CompactHashSet<Locale.FilteringMode> compactHashSet0 = CompactHashSet.create((Collection<? extends Locale.FilteringMode>) immutableMultiset0);
      int int0 = compactHashSet0.size();
      assertEquals(1, int0);
      assertTrue(compactHashSet0.contains(locale_FilteringMode0));
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      CompactHashSet<Integer> compactHashSet0 = new CompactHashSet<Integer>();
      boolean boolean0 = compactHashSet0.needsAllocArrays();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      BoundType[] boundTypeArray0 = new BoundType[2];
      CompactHashSet<BoundType> compactHashSet0 = CompactHashSet.create(boundTypeArray0);
      compactHashSet0.needsAllocArrays();
      assertEquals(1, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      CompactHashSet<Comparable<Object>> compactHashSet0 = CompactHashSet.createWithExpectedSize(0);
      Iterator<Comparable<Object>> iterator0 = compactHashSet0.iterator();
      assertNotNull(iterator0);
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Map.Entry<BoundType, BoundType>[] map_EntryArray0 = (Map.Entry<BoundType, BoundType>[]) Array.newInstance(Map.Entry.class, 7);
      CompactHashSet<Map.Entry<BoundType, BoundType>> compactHashSet0 = CompactHashSet.create(map_EntryArray0);
      int int0 = compactHashSet0.getSuccessor((-1));
      assertEquals(1, compactHashSet0.size());
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      CompactHashSet<LinkedHashSet<BoundType>> compactHashSet0 = CompactHashSet.create();
      int int0 = compactHashSet0.firstEntryIndex();
      assertEquals((-1), int0);
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      CompactHashSet<Comparable<Locale.Category>> compactHashSet0 = new CompactHashSet<Comparable<Locale.Category>>(2852);
      Set<Comparable<Locale.Category>> set0 = compactHashSet0.delegateOrNull();
      assertNull(set0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      BoundType[] boundTypeArray0 = new BoundType[0];
      CompactHashSet<BoundType> compactHashSet0 = CompactHashSet.create(boundTypeArray0);
      assertTrue(compactHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      CompactHashSet<Locale.FilteringMode> compactHashSet0 = CompactHashSet.create();
      int int0 = compactHashSet0.allocArrays();
      assertEquals(3, int0);
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      CompactHashSet<LinkedHashSet<BoundType>> compactHashSet0 = CompactHashSet.create();
      // Undeclared exception!
      try { 
        compactHashSet0.resizeEntries(0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      CompactHashSet<Comparable<Locale.FilteringMode>> compactHashSet0 = new CompactHashSet<Comparable<Locale.FilteringMode>>(3795);
      // Undeclared exception!
      try { 
        compactHashSet0.moveLastEntry(0, 2167);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      CompactHashSet<Locale.Category> compactHashSet0 = CompactHashSet.create();
      Locale.Category locale_Category0 = Locale.Category.FORMAT;
      // Undeclared exception!
      try { 
        compactHashSet0.insertEntry((-284), locale_Category0, 0, 0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      Locale.Category locale_Category0 = Locale.Category.FORMAT;
      ImmutableList<Locale.Category> immutableList0 = ImmutableList.of(locale_Category0, locale_Category0, locale_Category0, locale_Category0);
      CompactHashSet<Locale.Category> compactHashSet0 = CompactHashSet.create((Collection<? extends Locale.Category>) immutableList0);
      // Undeclared exception!
      try { 
        compactHashSet0.insertEntry(32, locale_Category0, 32, (-1173));
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 32
         //
         verifyException("com.google.common.collect.CompactHashSet", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      // Undeclared exception!
      try { 
        CompactHashSet.createWithExpectedSize((-2156));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Expected size must be >= 0
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      // Undeclared exception!
      try { 
        CompactHashSet.create((BoundType[]) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.collect.CompactHashSet", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      RegularImmutableSet<JdkBackedImmutableSet<BoundType>> regularImmutableSet0 = new RegularImmutableSet<JdkBackedImmutableSet<BoundType>>((Object[]) null, (-2235), (Object[]) null, 134);
      // Undeclared exception!
      try { 
        CompactHashSet.create((Collection<? extends JdkBackedImmutableSet<BoundType>>) regularImmutableSet0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.collect.RegularImmutableSet", e);
      }
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      Object object0 = new Object();
      ImmutableMultiset<Object> immutableMultiset0 = ImmutableMultiset.of(object0, object0, object0);
      CompactHashSet<Object> compactHashSet0 = CompactHashSet.create((Collection<?>) immutableMultiset0);
      // Undeclared exception!
      try { 
        compactHashSet0.allocArrays();
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Arrays already allocated
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      CompactHashSet<FilteredKeyMultimap<Object, Object>> compactHashSet0 = null;
      try {
        compactHashSet0 = new CompactHashSet<FilteredKeyMultimap<Object, Object>>((-1895));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Expected size must be >= 0
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      CompactHashSet<Map.Entry<Locale.Category, Locale.Category>> compactHashSet0 = CompactHashSet.create();
      boolean boolean0 = compactHashSet0.isEmpty();
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      CompactHashSet<Comparable<BoundType>> compactHashSet0 = new CompactHashSet<Comparable<BoundType>>();
      BoundType boundType0 = BoundType.CLOSED;
      compactHashSet0.add(boundType0);
      boolean boolean0 = compactHashSet0.isEmpty();
      assertEquals(1, compactHashSet0.size());
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      CompactHashSet<ImmutableMapEntrySet.RegularEntrySet<Object, Object>> compactHashSet0 = new CompactHashSet<ImmutableMapEntrySet.RegularEntrySet<Object, Object>>(31);
      int int0 = compactHashSet0.size();
      assertEquals(0, int0);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      CompactHashSet<Integer> compactHashSet0 = CompactHashSet.create();
      Stream<Integer> stream0 = compactHashSet0.parallelStream();
      Spliterator<Integer> spliterator0 = compactHashSet0.spliterator();
      CompactHashSet.create();
      Locale.Category locale_Category0 = Locale.Category.FORMAT;
      Object[] objectArray0 = new Object[6];
      objectArray0[0] = (Object) stream0;
      objectArray0[1] = (Object) locale_Category0;
      objectArray0[3] = (Object) spliterator0;
      objectArray0[4] = (Object) compactHashSet0;
      RegularImmutableSet<JdkBackedImmutableSet<BoundType>> regularImmutableSet0 = new RegularImmutableSet<JdkBackedImmutableSet<BoundType>>(objectArray0, 7, objectArray0, 7);
      CompactHashSet<JdkBackedImmutableSet<BoundType>> compactHashSet1 = CompactHashSet.create((Collection<? extends JdkBackedImmutableSet<BoundType>>) regularImmutableSet0);
      BoundType boundType0 = BoundType.CLOSED;
      ImmutableList<BoundType> immutableList0 = ImmutableList.of(boundType0);
      RegularImmutableAsList<BoundType> regularImmutableAsList0 = new RegularImmutableAsList<BoundType>(immutableList0, immutableList0);
      CompactHashSet<Locale.FilteringMode> compactHashSet2 = new CompactHashSet<Locale.FilteringMode>(7);
      JdkBackedImmutableSet<BoundType> jdkBackedImmutableSet0 = new JdkBackedImmutableSet<BoundType>(compactHashSet2, immutableList0);
      JdkBackedImmutableSet<BoundType> jdkBackedImmutableSet1 = new JdkBackedImmutableSet<BoundType>(jdkBackedImmutableSet0, immutableList0);
      compactHashSet1.add(jdkBackedImmutableSet1);
      assertEquals(6, compactHashSet1.size());
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      BoundType[] boundTypeArray0 = new BoundType[2];
      BoundType boundType0 = BoundType.CLOSED;
      boundTypeArray0[0] = boundType0;
      CompactHashSet<BoundType> compactHashSet0 = CompactHashSet.create(boundTypeArray0);
      boolean boolean0 = compactHashSet0.add(boundType0);
      assertEquals(2, compactHashSet0.size());
      assertTrue(compactHashSet0.contains(boundType0));
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      CompactHashSet<Integer> compactHashSet0 = CompactHashSet.create();
      compactHashSet0.clear();
      assertEquals(0, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      CompactHashSet<Comparable<Object>> compactHashSet0 = new CompactHashSet<Comparable<Object>>();
      compactHashSet0.trimToSize();
      assertTrue(compactHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      Comparable<Object>[] comparableArray0 = (Comparable<Object>[]) Array.newInstance(Comparable.class, 3);
      Comparable<Object> comparable0 = (Comparable<Object>) mock(Comparable.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(comparable0).toString();
      comparableArray0[0] = comparable0;
      comparableArray0[1] = comparable0;
      comparableArray0[2] = comparable0;
      ImmutableMultiset<Comparable<Object>> immutableMultiset0 = ImmutableMultiset.copyOf(comparableArray0);
      CompactHashSet<Comparable<Object>> compactHashSet0 = CompactHashSet.create((Collection<? extends Comparable<Object>>) immutableMultiset0);
      compactHashSet0.trimToSize();
      compactHashSet0.trimToSize();
      assertTrue(compactHashSet0.contains(comparable0));
      assertEquals(1, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      CompactHashSet<UnmodifiableSortedMultiset<BoundType>> compactHashSet0 = CompactHashSet.createWithExpectedSize(847);
      BoundType[] boundTypeArray0 = new BoundType[1];
      BoundType[] boundTypeArray1 = compactHashSet0.toArray(boundTypeArray0);
      assertSame(boundTypeArray1, boundTypeArray0);
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      CompactHashSet<Map.Entry<BoundType, BoundType>> compactHashSet0 = CompactHashSet.create();
      compactHashSet0.convertToHashFloodingResistantImplementation();
      Object[] objectArray0 = compactHashSet0.toArray();
      assertEquals(0, objectArray0.length);
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      CompactHashSet<Map.Entry<Locale.Category, Locale.Category>> compactHashSet0 = CompactHashSet.createWithExpectedSize(0);
      Object[] objectArray0 = compactHashSet0.toArray();
      assertEquals(0, objectArray0.length);
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      CompactHashSet<Comparable<BoundType>> compactHashSet0 = new CompactHashSet<Comparable<BoundType>>();
      BoundType boundType0 = BoundType.CLOSED;
      compactHashSet0.add(boundType0);
      Consumer<Comparable<BoundType>> consumer0 = (Consumer<Comparable<BoundType>>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      compactHashSet0.forEach(consumer0);
      assertFalse(compactHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      LinkedHashSet<Multisets.UnmodifiableMultiset<BoundType>> linkedHashSet0 = new LinkedHashSet<Multisets.UnmodifiableMultiset<BoundType>>();
      CompactHashSet<Multisets.UnmodifiableMultiset<BoundType>> compactHashSet0 = CompactHashSet.create((Collection<? extends Multisets.UnmodifiableMultiset<BoundType>>) linkedHashSet0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      compactHashSet0.forEach(consumer0);
      assertTrue(compactHashSet0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      BoundType[] boundTypeArray0 = new BoundType[2];
      CompactHashSet<BoundType> compactHashSet0 = CompactHashSet.create(boundTypeArray0);
      compactHashSet0.clear();
      // Undeclared exception!
      try { 
        Range.encloseAll((Iterable<BoundType>) compactHashSet0);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.collect.CompactHashSet$1", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      CompactHashSet<Integer> compactHashSet0 = new CompactHashSet<Integer>();
      compactHashSet0.convertToHashFloodingResistantImplementation();
      CompactHashSet<Object> compactHashSet1 = CompactHashSet.createWithExpectedSize(386);
      boolean boolean0 = compactHashSet1.containsAll(compactHashSet0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      CompactHashSet<Comparable<BoundType>> compactHashSet0 = new CompactHashSet<Comparable<BoundType>>();
      CompactHashSet.createWithExpectedSize(263);
      Locale.Category locale_Category0 = Locale.Category.FORMAT;
      ImmutableList.of(locale_Category0, locale_Category0);
      LinkedHashSet<Locale.Category>[] linkedHashSetArray0 = (LinkedHashSet<Locale.Category>[]) Array.newInstance(LinkedHashSet.class, 6);
      LinkedHashSet<Locale.Category> linkedHashSet0 = new LinkedHashSet<Locale.Category>();
      linkedHashSetArray0[0] = linkedHashSet0;
      LinkedHashSet<Locale.Category> linkedHashSet1 = new LinkedHashSet<Locale.Category>(linkedHashSet0);
      linkedHashSetArray0[1] = linkedHashSet1;
      CompactHashSet<LinkedHashSet<Locale.Category>> compactHashSet1 = CompactHashSet.create(linkedHashSetArray0);
      boolean boolean0 = compactHashSet1.retainAll(linkedHashSet1);
      assertTrue(boolean0);
      assertTrue(compactHashSet1.isEmpty());
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      Object object0 = new Object();
      LinkedHashSet<Locale.Category>[] linkedHashSetArray0 = (LinkedHashSet<Locale.Category>[]) Array.newInstance(LinkedHashSet.class, 4);
      CompactHashSet<LinkedHashSet<Locale.Category>> compactHashSet0 = CompactHashSet.create(linkedHashSetArray0);
      compactHashSet0.remove(object0);
      assertEquals(1, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      CompactHashSet<LinkedHashSet<Locale.Category>> compactHashSet0 = CompactHashSet.create();
      Locale.Category locale_Category0 = Locale.Category.FORMAT;
      boolean boolean0 = compactHashSet0.remove(locale_Category0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      CompactHashSet<Comparable<BoundType>> compactHashSet0 = new CompactHashSet<Comparable<BoundType>>();
      Object object0 = new Object();
      boolean boolean0 = compactHashSet0.contains(object0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      Object[] objectArray0 = new Object[7];
      Object object0 = new Object();
      objectArray0[0] = object0;
      Object object1 = new Object();
      objectArray0[1] = object1;
      Object object2 = new Object();
      objectArray0[2] = object2;
      Object object3 = new Object();
      objectArray0[3] = object3;
      Object object4 = new Object();
      objectArray0[4] = object4;
      Object object5 = new Object();
      objectArray0[5] = object5;
      Object object6 = new Object();
      objectArray0[6] = object6;
      RegularImmutableSet<JdkBackedImmutableSet<BoundType>> regularImmutableSet0 = new RegularImmutableSet<JdkBackedImmutableSet<BoundType>>(objectArray0, 0, objectArray0, (-2235));
      CompactHashSet<JdkBackedImmutableSet<BoundType>> compactHashSet0 = CompactHashSet.create((Collection<? extends JdkBackedImmutableSet<BoundType>>) regularImmutableSet0);
      BoundType boundType0 = BoundType.OPEN;
      ImmutableList<BoundType> immutableList0 = ImmutableList.of(boundType0);
      JdkBackedImmutableSet<BoundType> jdkBackedImmutableSet0 = new JdkBackedImmutableSet<BoundType>(compactHashSet0, immutableList0);
      compactHashSet0.add(jdkBackedImmutableSet0);
      assertEquals(8, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      Object[] objectArray0 = new Object[7];
      Object object0 = new Object();
      objectArray0[0] = object0;
      Object object1 = new Object();
      Object object2 = new Object();
      objectArray0[2] = object2;
      Object object3 = new Object();
      objectArray0[3] = object3;
      Object object4 = new Object();
      objectArray0[4] = object4;
      objectArray0[5] = object1;
      Object object5 = new Object();
      objectArray0[6] = object5;
      RegularImmutableSet<JdkBackedImmutableSet<BoundType>> regularImmutableSet0 = new RegularImmutableSet<JdkBackedImmutableSet<BoundType>>(objectArray0, 0, objectArray0, (-2235));
      CompactHashSet<JdkBackedImmutableSet<BoundType>> compactHashSet0 = CompactHashSet.create((Collection<? extends JdkBackedImmutableSet<BoundType>>) regularImmutableSet0);
      BoundType boundType0 = BoundType.OPEN;
      ImmutableList<BoundType> immutableList0 = ImmutableList.of(boundType0);
      JdkBackedImmutableSet<BoundType> jdkBackedImmutableSet0 = new JdkBackedImmutableSet<BoundType>(compactHashSet0, immutableList0);
      compactHashSet0.add(jdkBackedImmutableSet0);
      assertEquals(8, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      Object[] objectArray0 = new Object[9];
      CompactHashSet<Object> compactHashSet0 = CompactHashSet.create(objectArray0);
      compactHashSet0.isUsingHashFloodingResistance();
      assertEquals(1, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      LinkedHashSet<Locale.Category>[] linkedHashSetArray0 = (LinkedHashSet<Locale.Category>[]) Array.newInstance(LinkedHashSet.class, 3);
      CompactHashSet<LinkedHashSet<Locale.Category>> compactHashSet0 = CompactHashSet.create(linkedHashSetArray0);
      Set<LinkedHashSet<Locale.Category>> set0 = compactHashSet0.convertToHashFloodingResistantImplementation();
      assertEquals(1, set0.size());
      
      compactHashSet0.clear();
      assertEquals(0, compactHashSet0.size());
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      CompactHashSet<Integer> compactHashSet0 = new CompactHashSet<Integer>();
      // Undeclared exception!
      try { 
        compactHashSet0.init((-4343));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Expected size must be >= 0
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      Stack<Locale.Category> stack0 = new Stack<Locale.Category>();
      Iterator<Locale.Category> iterator0 = stack0.iterator();
      ImmutableSortedMultiset<Locale.Category> immutableSortedMultiset0 = ImmutableSortedMultiset.copyOf((Iterator<? extends Locale.Category>) iterator0);
      UnmodifiableSortedMultiset<Locale.Category> unmodifiableSortedMultiset0 = new UnmodifiableSortedMultiset<Locale.Category>(immutableSortedMultiset0);
      ImmutableMultiset<UnmodifiableSortedMultiset<Locale.Category>> immutableMultiset0 = ImmutableMultiset.of(unmodifiableSortedMultiset0, unmodifiableSortedMultiset0, unmodifiableSortedMultiset0);
      CompactHashSet<UnmodifiableSortedMultiset<Locale.Category>> compactHashSet0 = CompactHashSet.create((Collection<? extends UnmodifiableSortedMultiset<Locale.Category>>) immutableMultiset0);
      compactHashSet0.resizeEntries(2852);
      assertEquals(1, compactHashSet0.size());
      assertTrue(compactHashSet0.contains(unmodifiableSortedMultiset0));
  }
}
