/*
 * This file was automatically generated by EvoSuite
 * Wed Oct 23 15:38:01 GMT 2024
 */

package com.google.common.collect;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.google.common.collect.AllEqualOrdering;
import com.google.common.collect.ComparatorOrdering;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedMultiset;
import com.google.common.collect.NullsLastOrdering;
import com.google.common.collect.Ordering;
import com.google.common.collect.RegularImmutableSortedMultiset;
import com.google.common.collect.ReverseNaturalOrdering;
import com.google.common.collect.ReverseOrdering;
import com.google.common.collect.UnmodifiableSortedMultiset;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.Locale;
import java.util.function.ToDoubleFunction;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) 
public class Ordering_ESTest extends Ordering_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      AllEqualOrdering allEqualOrdering0 = new AllEqualOrdering();
      Ordering<Comparable<Integer>> ordering0 = allEqualOrdering0.reverse();
      Integer integer0 = new Integer(0);
      Integer integer1 = new Integer(0);
      Integer[] integerArray0 = new Integer[5];
      Integer integer2 = ordering0.min(integer0, integer0, integer1, integerArray0);
      assertTrue(integer2.equals((Object)integer1));
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Ordering.ArbitraryOrdering ordering_ArbitraryOrdering0 = new Ordering.ArbitraryOrdering();
      Ordering<Locale.Category> ordering0 = ordering_ArbitraryOrdering0.nullsLast();
      Locale.Category locale_Category0 = Locale.Category.DISPLAY;
      EnumSet<Locale.Category> enumSet0 = EnumSet.range(locale_Category0, locale_Category0);
      Locale.Category locale_Category1 = ordering0.max((Iterable<Locale.Category>) enumSet0);
      assertSame(locale_Category0, locale_Category1);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      ReverseNaturalOrdering reverseNaturalOrdering0 = ReverseNaturalOrdering.INSTANCE;
      Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.AUTOSELECT_FILTERING;
      Locale.FilteringMode locale_FilteringMode1 = reverseNaturalOrdering0.min(locale_FilteringMode0, locale_FilteringMode0);
      assertEquals(Locale.FilteringMode.AUTOSELECT_FILTERING, locale_FilteringMode1);
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      AllEqualOrdering allEqualOrdering0 = AllEqualOrdering.INSTANCE;
      NullsLastOrdering<Integer> nullsLastOrdering0 = new NullsLastOrdering<Integer>(allEqualOrdering0);
      ImmutableSet<Integer> immutableSet0 = ImmutableSet.of();
      boolean boolean0 = nullsLastOrdering0.isStrictlyOrdered(immutableSet0);
      assertTrue(boolean0);
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      AllEqualOrdering allEqualOrdering0 = AllEqualOrdering.INSTANCE;
      NullsLastOrdering<Integer> nullsLastOrdering0 = new NullsLastOrdering<Integer>(allEqualOrdering0);
      ImmutableSet<Integer> immutableSet0 = ImmutableSet.of();
      ImmutableList<Integer> immutableList0 = allEqualOrdering0.immutableSortedCopy((Iterable<Integer>) immutableSet0);
      ReverseOrdering<Integer> reverseOrdering0 = new ReverseOrdering<Integer>(nullsLastOrdering0);
      // Undeclared exception!
      try { 
        reverseOrdering0.leastOf((Iterable<Integer>) immutableList0, (-1767));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // k cannot be negative but was: -1767
         //
         verifyException("com.google.common.collect.CollectPreconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      ToDoubleFunction<Object> toDoubleFunction0 = (ToDoubleFunction<Object>) mock(ToDoubleFunction.class, new ViolatedAssumptionAnswer());
      Comparator<UnmodifiableSortedMultiset<Integer>> comparator0 = Comparator.comparingDouble((ToDoubleFunction<? super UnmodifiableSortedMultiset<Integer>>) toDoubleFunction0);
      ComparatorOrdering<UnmodifiableSortedMultiset<Integer>> comparatorOrdering0 = new ComparatorOrdering<UnmodifiableSortedMultiset<Integer>>(comparator0);
      Ordering<UnmodifiableSortedMultiset<Integer>> ordering0 = Ordering.from((Comparator<UnmodifiableSortedMultiset<Integer>>) comparatorOrdering0);
      assertNotNull(ordering0);
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      Ordering.ArbitraryOrdering ordering_ArbitraryOrdering0 = new Ordering.ArbitraryOrdering();
      String string0 = ordering_ArbitraryOrdering0.toString();
      assertEquals("Ordering.arbitrary()", string0);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      Ordering<Object> ordering0 = Ordering.arbitrary();
      ReverseOrdering<Object> reverseOrdering0 = new ReverseOrdering<Object>(ordering0);
      Integer[] integerArray0 = new Integer[6];
      Integer integer0 = new Integer(1004);
      integerArray0[0] = integer0;
      integerArray0[1] = integer0;
      integerArray0[2] = integerArray0[1];
      integerArray0[3] = integerArray0[0];
      Integer integer1 = new Integer(2706);
      integerArray0[4] = integer1;
      integerArray0[5] = integerArray0[3];
      ImmutableSortedMultiset<Integer> immutableSortedMultiset0 = ImmutableSortedMultiset.copyOf(integerArray0);
      Integer integer2 = reverseOrdering0.min((Iterable<Integer>) immutableSortedMultiset0);
      assertEquals(2706, (int)integer2);
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      ImmutableMultiset<Comparator<Object>> immutableMultiset0 = ImmutableMultiset.of();
      Ordering<UnmodifiableSortedMultiset<Locale.FilteringMode>> ordering0 = Ordering.compound((Iterable<? extends Comparator<? super UnmodifiableSortedMultiset<Locale.FilteringMode>>>) immutableMultiset0);
      assertNotNull(ordering0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Ordering.ArbitraryOrdering ordering_ArbitraryOrdering0 = new Ordering.ArbitraryOrdering();
      Ordering<Locale.Category> ordering0 = ordering_ArbitraryOrdering0.nullsLast();
      Locale.Category locale_Category0 = Locale.Category.DISPLAY;
      EnumSet<Locale.Category> enumSet0 = EnumSet.range(locale_Category0, locale_Category0);
      List<Locale.Category> list0 = ordering0.sortedCopy((Iterable<Locale.Category>) enumSet0);
      assertFalse(list0.isEmpty());
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      Ordering.ArbitraryOrdering ordering_ArbitraryOrdering0 = new Ordering.ArbitraryOrdering();
      Ordering<Locale.Category> ordering0 = ordering_ArbitraryOrdering0.nullsLast();
      Ordering<Locale.Category> ordering1 = ordering0.reverse();
      assertFalse(ordering1.equals((Object)ordering0));
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      Integer integer0 = new Integer(0);
      Integer[] integerArray0 = new Integer[5];
      // Undeclared exception!
      try { 
        Ordering.explicit(integer0, integerArray0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // null key in entry: null=1
         //
         verifyException("com.google.common.collect.CollectPreconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      AllEqualOrdering allEqualOrdering0 = new AllEqualOrdering();
      RegularImmutableSortedMultiset<Comparable<Integer>> regularImmutableSortedMultiset0 = new RegularImmutableSortedMultiset<Comparable<Integer>>(allEqualOrdering0);
      ImmutableList<Comparable<Integer>> immutableList0 = regularImmutableSortedMultiset0.asList();
      Ordering<Comparable<Integer>> ordering0 = Ordering.explicit((List<Comparable<Integer>>) immutableList0);
      Ordering<Comparable<Integer>> ordering1 = Ordering.from(ordering0);
      assertSame(ordering1, ordering0);
  }
}
